# Supabase Project Setup - Auto-Detection and Configuration
# This script automatically detects and configures Supabase projects

param(
    [string]$ProjectPath = ".",
    [string]$ProjectRef,
    [switch]$Force,
    [switch]$Validate
)

Write-Host "üîç Supabase Project Auto-Setup" -ForegroundColor Cyan
Write-Host "==============================" -ForegroundColor Cyan

# Function to detect project type
function Get-ProjectType {
    param($Path)
    
    if (Test-Path "$Path\package.json") {
        $packageJson = Get-Content "$Path\package.json" | ConvertFrom-Json
        
        if ($packageJson.dependencies -and ($packageJson.dependencies.'next' -or $packageJson.dependencies.'@next/core')) {
            return "Next.js"
        }
        elseif ($packageJson.dependencies -and $packageJson.dependencies.'react') {
            return "React"
        }
        elseif ($packageJson.dependencies -and $packageJson.dependencies.'vue') {
            return "Vue"
        }
        else {
            return "JavaScript"
        }
    }
    elseif (Test-Path "$Path\requirements.txt" -or (Test-Path "$Path\*.py")) {
        return "Python"
    }
    else {
        return "Unknown"
    }
}

# Function to get all Supabase projects
function Get-SupabaseProjects {
    try {
        $projectsOutput = supabase projects list --output json 2>$null
        if ($LASTEXITCODE -eq 0) {
            $projects = $projectsOutput | ConvertFrom-Json
            Write-Host "‚úÖ Found $($projects.Count) Supabase projects" -ForegroundColor Green
            return $projects
        }
        else {
            Write-Host "‚ùå Failed to fetch Supabase projects" -ForegroundColor Red
            return $null
        }
    }
    catch {
        Write-Host "‚ùå Error fetching projects: $_" -ForegroundColor Red
        return $null
    }
}

# Function to get project credentials
function Get-ProjectCredentials {
    param($ProjectRef)
    
    try {
        Write-Host "üîê Fetching credentials for project: $ProjectRef" -ForegroundColor Yellow
        
        # Get API keys
        $keysOutput = supabase projects api-keys --project-ref $ProjectRef --output json 2>$null
        if ($LASTEXITCODE -ne 0) {
            Write-Host "‚ùå Failed to fetch API keys for project $ProjectRef" -ForegroundColor Red
            return $null
        }
        
        $keys = $keysOutput | ConvertFrom-Json
        
        # Construct project URL
        $projectUrl = "https://$ProjectRef.supabase.co"
        
        # Find anon and service_role keys
        $anonKey = ($keys | Where-Object { $_.name -eq "anon" }).api_key
        $serviceKey = ($keys | Where-Object { $_.name -eq "service_role" }).api_key
        
        if (!$anonKey -or !$serviceKey) {
            Write-Host "‚ùå Could not find required API keys (anon/service_role)" -ForegroundColor Red
            return $null
        }
        
        return @{
            ProjectUrl = $projectUrl
            AnonKey = $anonKey
            ServiceKey = $serviceKey
            ProjectRef = $ProjectRef
        }
    }
    catch {
        Write-Host "‚ùå Error fetching credentials: $_" -ForegroundColor Red
        return $null
    }
}

# Function to create environment file
function New-EnvironmentFile {
    param($Path, $Credentials, $ProjectType)
    
    $envFile = if ($ProjectType -eq "Next.js" -or $ProjectType -eq "React") { 
        "$Path\.env.local" 
    } else { 
        "$Path\.env" 
    }
    
    # Backup existing file if it exists
    if (Test-Path $envFile) {
        $backup = "$envFile.backup.$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        Copy-Item $envFile $backup
        Write-Host "üìÑ Backed up existing env file to: $(Split-Path $backup -Leaf)" -ForegroundColor Yellow
    }
    
    $envContent = @"
# Supabase Configuration
# Generated by supabase-project-setup.ps1 on $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

# Project URL
NEXT_PUBLIC_SUPABASE_URL=$($Credentials.ProjectUrl)
SUPABASE_URL=$($Credentials.ProjectUrl)

# Public anon key (safe to use in browser)
NEXT_PUBLIC_SUPABASE_ANON_KEY=$($Credentials.AnonKey)
SUPABASE_ANON_KEY=$($Credentials.AnonKey)

# Service role key (server-side only - never expose to browser)
SUPABASE_SERVICE_ROLE_KEY=$($Credentials.ServiceKey)

# Database connection string for direct PostgreSQL access
DATABASE_URL=postgresql://postgres:[YOUR-PASSWORD]@db.$($Credentials.ProjectRef).supabase.co:5432/postgres
DIRECT_URL=postgresql://postgres:[YOUR-PASSWORD]@db.$($Credentials.ProjectRef).supabase.co:5432/postgres

# Project reference for CLI operations
SUPABASE_PROJECT_REF=$($Credentials.ProjectRef)
"@

    try {
        $envContent | Out-File -FilePath $envFile -Encoding utf8
        Write-Host "‚úÖ Created environment file: $(Split-Path $envFile -Leaf)" -ForegroundColor Green
        return $true
    }
    catch {
        Write-Host "‚ùå Failed to create environment file: $_" -ForegroundColor Red
        return $false
    }
}

# Function to create TypeScript types generation script
function New-TypesGenerationScript {
    param($Path, $ProjectRef)
    
    $scriptContent = @"
{
  "scripts": {
    "types:generate": "supabase gen types typescript --project-id $ProjectRef --schema public > src/types/database.types.ts",
    "types:watch": "nodemon --watch supabase/migrations --ext sql --exec \"npm run types:generate\"",
    "supabase:start": "supabase start",
    "supabase:stop": "supabase stop",
    "supabase:status": "supabase status",
    "supabase:reset": "supabase db reset"
  }
}
"@

    $packageJsonPath = "$Path\package.json"
    if (Test-Path $packageJsonPath) {
        try {
            $packageJson = Get-Content $packageJsonPath | ConvertFrom-Json
            $newScripts = $scriptContent | ConvertFrom-Json | Select-Object -ExpandProperty scripts
            
            # Add new scripts to existing package.json
            if (!$packageJson.scripts) {
                $packageJson | Add-Member -Type NoteProperty -Name "scripts" -Value @{}
            }
            
            foreach ($scriptName in $newScripts.PSObject.Properties.Name) {
                $packageJson.scripts | Add-Member -Type NoteProperty -Name $scriptName -Value $newScripts.$scriptName -Force
            }
            
            $packageJson | ConvertTo-Json -Depth 10 | Out-File -FilePath $packageJsonPath -Encoding utf8
            Write-Host "‚úÖ Added Supabase scripts to package.json" -ForegroundColor Green
        }
        catch {
            Write-Host "‚ö†Ô∏è Could not update package.json scripts: $_" -ForegroundColor Yellow
        }
    }
    
    # Create types directory
    $typesDir = "$Path\src\types"
    if (!(Test-Path $typesDir)) {
        New-Item -ItemType Directory -Path $typesDir -Force | Out-Null
        Write-Host "‚úÖ Created types directory: src\types" -ForegroundColor Green
    }
}

# Function to initialize Supabase in project
function Initialize-SupabaseProject {
    param($Path, $ProjectRef)
    
    Push-Location $Path
    try {
        # Check if already initialized
        if (Test-Path "supabase\config.toml") {
            Write-Host "‚úÖ Project already initialized with Supabase" -ForegroundColor Green
            return $true
        }
        
        # Initialize Supabase
        Write-Host "üöÄ Initializing Supabase in project..." -ForegroundColor Yellow
        supabase init
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ Supabase initialized successfully" -ForegroundColor Green
            
            # Link to remote project if provided
            if ($ProjectRef) {
                Write-Host "üîó Linking to remote project: $ProjectRef" -ForegroundColor Yellow
                supabase link --project-ref $ProjectRef
                
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "‚úÖ Linked to remote project successfully" -ForegroundColor Green
                }
                else {
                    Write-Host "‚ö†Ô∏è Could not link to remote project (you may need to do this manually)" -ForegroundColor Yellow
                }
            }
            
            return $true
        }
        else {
            Write-Host "‚ùå Failed to initialize Supabase" -ForegroundColor Red
            return $false
        }
    }
    finally {
        Pop-Location
    }
}

# Function to validate project setup
function Test-ProjectSetup {
    param($Path)
    
    Write-Host "üß™ Validating project setup..." -ForegroundColor Yellow
    
    $success = $true
    
    # Check for environment file
    $envFiles = @(".env.local", ".env")
    $envFound = $false
    foreach ($envFile in $envFiles) {
        if (Test-Path "$Path\$envFile") {
            Write-Host "‚úÖ Environment file found: $envFile" -ForegroundColor Green
            $envFound = $true
            
            # Check if it contains Supabase config
            $content = Get-Content "$Path\$envFile" -Raw
            if ($content -match "SUPABASE_URL" -and $content -match "SUPABASE_ANON_KEY") {
                Write-Host "‚úÖ Environment file contains Supabase configuration" -ForegroundColor Green
            }
            else {
                Write-Host "‚ùå Environment file missing Supabase configuration" -ForegroundColor Red
                $success = $false
            }
            break
        }
    }
    
    if (!$envFound) {
        Write-Host "‚ùå No environment file found" -ForegroundColor Red
        $success = $false
    }
    
    # Check Supabase initialization
    if (Test-Path "$Path\supabase\config.toml") {
        Write-Host "‚úÖ Supabase configuration found" -ForegroundColor Green
    }
    else {
        Write-Host "‚ö†Ô∏è Supabase not initialized in project" -ForegroundColor Yellow
    }
    
    return $success
}

# Main execution
try {
    $projectPath = Resolve-Path $ProjectPath
    Write-Host "üìÅ Project path: $projectPath" -ForegroundColor Cyan
    
    # Validation mode
    if ($Validate) {
        $isValid = Test-ProjectSetup $projectPath
        if ($isValid) {
            Write-Host "üéâ Project setup is valid!" -ForegroundColor Green
            exit 0
        }
        else {
            Write-Host "‚ùå Project setup has issues" -ForegroundColor Red
            exit 1
        }
    }
    
    # Detect project type
    $projectType = Get-ProjectType $projectPath
    Write-Host "üèóÔ∏è Project type detected: $projectType" -ForegroundColor Cyan
    
    # Get available Supabase projects
    $projects = Get-SupabaseProjects
    if (!$projects) {
        Write-Host "‚ùå Cannot proceed without Supabase project access" -ForegroundColor Red
        exit 1
    }
    
    # Select project
    if (!$ProjectRef) {
        if ($projects.Count -eq 1) {
            $ProjectRef = $projects[0].ref
            Write-Host "üéØ Auto-selected project: $($projects[0].name) ($ProjectRef)" -ForegroundColor Green
        }
        else {
            Write-Host "üìã Available projects:" -ForegroundColor Yellow
            for ($i = 0; $i -lt $projects.Count; $i++) {
                Write-Host "  $($i + 1). $($projects[$i].name) ($($projects[$i].ref))" -ForegroundColor White
            }
            
            do {
                $selection = Read-Host "Select project number (1-$($projects.Count))"
                $selectionInt = 0
                if ([int]::TryParse($selection, [ref]$selectionInt) -and $selectionInt -ge 1 -and $selectionInt -le $projects.Count) {
                    $ProjectRef = $projects[$selectionInt - 1].ref
                    break
                }
                Write-Host "Invalid selection. Please enter a number between 1 and $($projects.Count)." -ForegroundColor Red
            } while ($true)
        }
    }
    
    # Get project credentials
    $credentials = Get-ProjectCredentials $ProjectRef
    if (!$credentials) {
        Write-Host "‚ùå Could not fetch project credentials" -ForegroundColor Red
        exit 1
    }
    
    Write-Host "‚úÖ Successfully retrieved credentials for: $ProjectRef" -ForegroundColor Green
    
    # Create environment file
    if (!(New-EnvironmentFile $projectPath $credentials $projectType)) {
        Write-Host "‚ùå Failed to create environment file" -ForegroundColor Red
        exit 1
    }
    
    # Create TypeScript types generation
    New-TypesGenerationScript $projectPath $ProjectRef
    
    # Initialize Supabase project
    Initialize-SupabaseProject $projectPath $ProjectRef
    
    # Validate setup
    if (Test-ProjectSetup $projectPath) {
        Write-Host "" -ForegroundColor White
        Write-Host "üéâ SUCCESS! Project configured for Supabase" -ForegroundColor Green
        Write-Host "‚úÖ Environment variables configured" -ForegroundColor Green
        Write-Host "‚úÖ TypeScript types generation ready" -ForegroundColor Green
        Write-Host "‚úÖ Supabase CLI integrated" -ForegroundColor Green
        Write-Host "" -ForegroundColor White
        Write-Host "üìã Next Steps:" -ForegroundColor Cyan
        Write-Host "1. Install Supabase client: npm install @supabase/supabase-js" -ForegroundColor White
        Write-Host "2. Generate types: npm run types:generate" -ForegroundColor White
        Write-Host "3. Set up MCP integration: .\supabase-mcp-setup.ps1" -ForegroundColor White
        exit 0
    }
    else {
        Write-Host "‚ùå Setup completed but validation failed" -ForegroundColor Red
        exit 1
    }
}
catch {
    Write-Host "‚ùå Unexpected error during setup: $_" -ForegroundColor Red
    exit 1
}